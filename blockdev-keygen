#!/bin/sh
#
# This handles sensitive data that must not be swapped out
# or written out to disk unencrypted.
#
# Important: before running this script the caller has
# to check for unsafe swap partitions. This is done in 
# choose_method/encrypt/do_options.
# 
# Assumption: This runs as part of d-i. Therefore, temp
# files outside of /target reside in a ramdisk. Process
# information (think [ "$pass" ]) is not exposed to anyone
# but the installing user.
#
# Released under the GNU GPL.
# Copyright 2005, Max Vozeler <xam@debian.org>
#

. /usr/share/debconf/confmodule

umask 077
minlen=8

passphrase_is_weak () {
    test $(echo -n "$1" | wc -c) -lt $minlen
}

get_passphrase () {
    local pass_ok

    pass_ok=0
    while [ $pass_ok -eq 0 ]; do
        templ="partman-crypto/passphrase"
        db_set $templ ""
        db_fset $templ seen false
        db_subst $templ DEVICE "$description"
        db_input critical $templ
        db_go || return 1
        db_get $templ || RET=''
        pass=$RET
        if [ -z "$pass" ]; then
            templ="partman-crypto/passphrase-empty"
            db_fset $templ seen false
            db_input critical $templ
            db_go || true
            continue
        fi
    
        templ="partman-crypto/passphrase-again"
        db_set $templ ""
        db_fset $templ seen false
        db_input critical $templ
        db_go || return 1
        db_get $templ || RET=''
        if [ "$pass" != "$RET" ]; then
            templ="partman-crypto/passphrase-mismatch"
            db_fset $templ seen false
            db_input critical $templ
            db_go || true
            continue
        fi

        if passphrase_is_weak "$pass"; then
            templ="partman-crypto/weak_passphrase"
            db_set $templ false
            db_fset $templ seen false
            db_subst $templ MINIMUM $minlen
            db_input critical $templ || true
            db_go || true
            db_get $templ || RET=''
        
            if [ "$RET" != true ]; then
                # user doesn't want to force weak passphrase
                continue
           fi
        fi

        pass_ok=1
    done

    db_set partman-crypto/passphrase ""
    db_set partman-crypto/passphrase-again ""

    if [ $pass_ok -eq 1 ]; then
        echo "$pass"
    fi
}

read_random () {
    local keybytes
    keybytes=$1

    db_capb
    set -- $RET 
    for cap in $*; do
        if [ "$cap" = plugin-entropy-text ]; then
            use_entropy_plugin=yes
        fi
    done

    if [ -z "$use_entropy_plugin" ]; then
        db_fset partman-crypto/tools_missing seen false
        db_input critical partman-crypto/tools_missing
        db_go || true
        return 1
    fi

    db_set partman-crypto/keysize $keysize
    db_fset partman-crypto/entropy-text seen false
    db_subst partman-crypto/entropy-text DEVICE "$description"
    db_input critical partman-crypto/entropy-text
    db_go || return 1

    return 0
}

# Fifo provided by cdebconf-entropy plugins
randfifo=/var/run/random.fifo

gnupg_encrypt () {
    local keyfile passfifo gpgopts
    keyfile=$1
    passfifo=$2
    gpgopts="--batch --no-options --no-random-seed-file --no-default-keyring --keyring /dev/null --passphrase-fd 3 --symmetric -a"

    while [ ! -p $randfifo ]; do 
        sleep 1
    done

    base64 < $randfifo | gpg $gpgopts 3< $passfifo > $keyfile
}

# Creates a GnuPG keyfile for use by loop-AES.
# (v3 key format: 2925 bytes in base64)
create_gnupg_keyfile () {
    local file pass passfifo pid
    file=$1
    pass=$2

    passfifo=$file.pass
    if [ ! -p $passfifo ]; then
        mknod $passfifo p
        chmod 0600 $passfifo
    fi

    # Fork off gnupg encrypting pipe
    echo -n "$pass" > $passfifo &
    gnupg_encrypt $file $passfifo &
    pid=$!

    # Call plugin to feed randfifo
    read_random 2925
    if [ $? -ne 0 ] || !wait $pid; then
        rm $file
        return 1
    fi

    # for use by init.d/crypto
    echo -n "$pass" > $passfifo &
    return 0
}

description=$1
keyfile=$2

if [ -z "$description" ]; then
    echo "usage: $0 description [keyfile]"
    exit 1
fi

# Log available entropy
logger -t partman-crypto available kernel entropy: $(cat /proc/sys/kernel/random/entropy_avail) bits

pass=$(get_passphrase)
if [ -z "$pass" ]; then
    db_fset partman-crypto/keyfile-problem seen false
    db_input critical partman-crypto/keyfile-problem
    db_go || true
    exit 1
fi

if [ -z $keyfile ]; then
    echo -n "$pass"
else
    if ! create_gnupg_keyfile $keyfile "$pass"; then
        db_fset partman-crypto/keyfile-problem seen false
        db_input critical partman-crypto/keyfile-problem
        db_go || true
        exit 1
    fi
fi

