#!/bin/sh

# "Setup encrypted volumes" in the main menu.
#  1. Checks required tools
#  2. Checks for valid cipher options
#  3. Commits partman changes
#  4. Checks for safe swap 
#  5. Creates keyfiles
#  6. Erases to-be-encrypted partitions
#  7. Does losetup/dmsetup
#  8. Restarts partman

. /lib/partman/definitions.sh
. /lib/partman/crypto_tools.sh

check_required_tools() {
	local tools

	tools=""
	case $1 in
		dm-crypt)
			tools="/sbin/dmsetup /sbin/cryptsetup"
			;;
		loop-AES)
			tools="/usr/bin/gpg /bin/base64"
			;;
	esac

	for tool in $tools; do
		if [ ! -x $tool ]; then
			db_fset partman-crypto/tools_missing seen false
			db_input critical partman-crypto/tools_missing
			db_go || true
			exit 1
		fi
	done
}

check_required_options() {
	local id type list options
	id=$1
	type=$2

	options=""
	case $type in
		dm-crypt)
			options="cipher keytype keyhash ivalgorithm keysize"
			;;
		loop-AES)
			options="cipher keytype"
			;;
	esac

	list=""
	for opt in $options; do
		[ -f $id/$opt ] && continue
		db_metaget partman-crypto/text/specify_$opt description || RET="$opt:"
		desc=$RET
		db_metaget partman-crypto/text/missing description || RET="missing"
		value=$RET
		if [ "$list" ]; then
			list="$list
$desc $value"
		else
			list="$desc $value"
		fi
	done

	# If list is non-empty, at least one option is missing
	if [ ! -z "$list" ]; then
		templ="partman-crypto/options_missing"
		db_fset $templ seen false
		db_subst $templ DEVICE "$(humandev $path)"
		db_subst $templ ITEMS "$list"
		db_input critical $templ
		db_go || true
		exit 1
	fi
}

# Show warning before anything else
# (should be removed once the code has been audited)
templ="partman-crypto/warning_experimental_nonaudit"
db_input critical $templ
db_go || true
db_get $templ || RET=''
if [ "$RET" != true ]; then
	exit 0
fi

# check crypto options
crypt=
for dev in $DEVICES/*; do
	[ -d "$dev" ] || continue
	cd $dev

	partitions=
	open_dialog PARTITIONS
	while { read_line num id size type fs path name; [ "$id" ]; }; do
		[ "$fs" != free ] || continue
		partitions="$partitions $id,$num,$path"
	done
	close_dialog
	
	for p in $partitions; do
		set -- $(IFS=, && echo $p)
		id=$1
		num=$2
		path=$3

		[ -f $id/method ] || continue
		[ -f $id/crypto_type ] || continue

		method=$(cat $id/method)
		if [ $method != crypto ]; then
			continue
		fi
		type=$(cat $id/crypto_type)
		crypt=yes

		check_required_tools $type
		check_required_options $id $type
	done
done

if [ -z $crypt ]; then
	db_fset partman-crypto/nothing_to_setup seen false
	db_input critical partman-crypto/nothing_to_setup
	db_go || true
	exit 0
fi

# this comes from partman-lvm
confirm_changes () {
    local dev x part partitions num id size type fs path name filesystem partitems items
    # Compute the changes we are going to do
    partitems=''
    items=''
    for dev in $DEVICES/*; do
	[ -d "$dev" ] || continue
	cd $dev

	open_dialog IS_CHANGED
	read_line x
	close_dialog
	if [ "$x" = yes ]; then
	    partitems="${partitems}   $(humandev $(cat device))
"
	fi

	partitions=
	open_dialog PARTITIONS
	while { read_line num id size type fs path name; [ "$id" ]; }; do
	    [ "$fs" != free ] || continue
	    partitions="$partitions $id,$num"
	done
	close_dialog
	
	for part in $partitions; do
	    id=${part%,*}
	    num=${part#*,}
            [ -f $id/method -a -f $id/format \
                -a -f $id/visual_filesystem ] || continue
            [ -f $id/filesystem -o ! -f $id/formatted \
                -o $id/formatted -ot $id/method ] || continue
            [ ! -f $id/filesystem -o ! -f $id/formatted \
                -o $id/formatted -ot $id/method \
                -o $id/formatted -ot $id/filesystem ] || continue
	    filesystem=$(cat $id/visual_filesystem)
	    db_subst partman/text/confirm_item TYPE "$filesystem"
	    db_subst partman/text/confirm_item PARTITION "$num"
	    db_subst partman/text/confirm_item DEVICE $(humandev $(cat device))
	    db_metaget partman/text/confirm_item description
	    
	    items="${items}   ${RET}
"
	done
    done

    if [ "$items" ]; then
	db_metaget partman/text/confirm_item_header description
	items="$RET
$items"
    fi
    
    if [ "$partitems" ]; then
	db_metaget partman/text/confirm_partitem_header description
	partitems="$RET
$partitems"
    fi
    
    if [ "$partitems$items" ]; then
	if [ -z "$items" ]; then
	    x="$partitems"
	elif [ -z "$partitems" ]; then
	    x="$items"
	else
	    x="$partitems
$items"
	fi
	db_subst partman-crypto/confirm ITEMS "$x"
	db_input critical partman-crypto/confirm
	db_go || true
	db_get partman-crypto/confirm
	if [ "$RET" = false ]; then
	    db_reset partman-crypto/confirm
	    return 1
	else
	    db_reset partman-crypto/confirm
	    return 0
	fi
    else
	db_input critical partman-crypto/confirm_nochanges
	db_go || true
	db_get partman-crypto/confirm_nochanges
	if [ "$RET" = false ]; then
	    db_reset partman-crypto/confirm_nochanges
	    return 1
	else
	    db_reset partman-crypto/confirm_nochanges
	    return 0
	fi
    fi
}

confirm_changes || exit 0

# Commit the changes

for s in /lib/partman/commit.d/*; do
    if [ -x $s ]; then
	$s || {
	    db_input high partman-crypto/commit_failed || true
	    db_go || true
	    for s in /lib/partman/init.d/*; do
		if [ -x $s ]; then
		    $s || exit 255
		fi
	    done
	    exit 0
	}
    fi
done

if ! swap_is_safe; then
	db_fset partman-crypto/unsafe_swap seen false
	db_input critical partman-crypto/unsafe_swap
	db_go || true
	exit 1
fi

# Erase crypto-backing partitions

for dev in $DEVICES/*; do
	[ -d "$dev" ] || continue
	cd $dev

	partitions=
	open_dialog PARTITIONS
	while { read_line num id size type fs path name; [ "$id" ]; }; do
		[ "$fs" != free ] || continue
		partitions="$partitions $id,$size,$path"
	done
	close_dialog
	
	for part in $partitions; do
		set -- $(IFS=, && echo $part)
		id=$1
		size=$2
		path=$3

		[ -f $id/method ] || continue
		method=$(cat $id/method)
		if [ $method != crypto ]; then
			continue
		fi

		if [ -f $id/crypt_active ] || [ -f $id/skip_erase ]; then
			continue
		fi

		if ! dev_wipe $path $size $(cat $id/crypto_type); then
			db_fset partman-crypto/commit_failed seen false
			db_input critical partman-crypto/commit_failed
			db_go || true
			exit 1
		fi
	done
done

create_keyfile () {
	local dev keytype keyfile keysize
	dev=$1
	keytype=$2
	keyfile=$3
	keysize=$4
  
	test -x /bin/blockdev-keygen || return 1
	/bin/blockdev-keygen "$(humandev $dev)" $keytype "$keyfile" $keysize || return 2
	return 0
}

# Create keys and do losetup/dmsetup

for dev in $DEVICES/*; do
	[ -d "$dev" ] || continue
	cd $dev

	partitions=
	open_dialog PARTITIONS
	while { read_line num id size type fs path name; [ "$id" ]; }; do
		[ "$fs" != free ] || continue
		partitions="$partitions $id,$num,$path"
	done
	close_dialog
	
	for part in $partitions; do
		set -- $(IFS=, && echo $part)
		id=$1
		num=$2
		path=$3

		[ -f $id/method ] || continue
		[ -f $id/crypto_type ] || continue
		[ -f $id/cipher ] || continue
		[ -f $id/keytype ] || continue

		method=$(cat $id/method)
		if [ $method != crypto ]; then
			continue
		fi

		type=$(cat $id/crypto_type)
		keytype=$(cat $id/keytype)
		cipher=$(cat $id/cipher)

		# Cryptsetup uses create_keyfile for all keytypes
		if [ $keytype = keyfile ] || [ $type != loop-AES ]; then
			keyfile=$dev/$id/$(mapdevfs $path | tr / _)
			if [ $type = loop-AES ]; then
				keyfile="${keyfile#_}.gpg"
			fi
			if [ ! -f $keyfile ]; then
				if [ $type != loop-AES ]; then
					keysize=""
					[ -f $id/keysize ] && keysize=$(cat $id/keysize)
					create_keyfile $path $keytype $keyfile $keysize
				else
					create_keyfile $path $keytype $keyfile
				fi
				if [ $? -ne 0 ]; then
					db_fset partman-crypto/commit_failed seen false
					db_input critical partman-crypto/commit_failed
					db_go || true
					failed=1
					break
				fi
			fi

			echo $keyfile > $id/keyfile
		fi

		if [ ! -f $id/crypt_active ]; then
			log "setting up encrypted device for $path"

			if ! setup_cryptdev $type $id $path; then
				db_fset partman-crypto/commit_failed seen false
				db_input critical partman-crypto/commit_failed
				db_go || true
				failed=1
				break
			fi
		fi
	done
done

if [ $failed ]; then
	exit 1
fi

stop_parted_server

restart_partman
