#!/bin/sh

# This script does the following:
# loop-AES:  changes the devices of encrypted loop mounts in fstab
#            from /dev/loop/.. to their real devices and adjusts options.
# dm-crypt:  creates /etc/crypttab entries
# luks:      creates /etc/crypttab entries

. /lib/partman/definitions.sh

loopaes_fix_fstab () {
    local realdev realdevdir cryptdev cryptdevdir entry opts cipher keytype newopts keyfile mnt
    realdev=$1
    realdevdir=$2
    cryptdev=$3
    cryptdevdir=$4

    entry=$(grep ^$cryptdev /target/etc/fstab)
    if [ -z "$entry" ]; then
        return 1
    fi

    cipher=$(cat $realdevdir/cipher)
    keytype=$(cat $realdevdir/keytype)
    
    # add options
    opts=$(set -- $entry && echo $4)
    newopts="loop=${cryptdev},encryption=${cipher}"

    # add gpgkey= option if applicable
    if [ $keytype = keyfile ] && [ -f $realdevdir/keyfile ]; then
        keyfile=$(basename $(cat $realdevdir/keyfile))
        newopts="${newopts},gpgkey=/etc/loopkeys/$keyfile"
    fi

    # handle non-swap partitions with random key
    if [ $keytype = random ] && [ -f $cryptdevdir/mountpoint ]; then
        mnt=$(cat $cryptdevdir/mountpoint)
        if [ $mnt = /tmp ]; then
            newopts="${newopts},phash=random/1777"
        else 
            newopts="${newopts},phash=random"
        fi
    fi

    # insert the new options into fstab
    # XXX: what happens for
    # /dev/foo /path auto noauto
    sed -i "\#^$cryptdev# { s#\($opts\)\([[:blank:]]\)#\1,$newopts\2# }" /target/etc/fstab

    # replace loop with realdev
    sed -i "s#^$cryptdev#$realdev#" /target/etc/fstab

    return 0
}

add_crypttab_entry () {
    local realdev realdevdir cryptdev cryptdevdir dmtype opts keyfile method mnt target source
    realdev=$1
    realdevdir=$2
    cryptdev=$3
    cryptdevdir=$4
    dmtype=$5

    # Set basic options
    if [ $dmtype = luks ]; then
        opts="luks"
    elif [ $dmtype = dm-crypt ]; then
        for opt in cipher keytype ivalgorithm keyhash keysize; do
            eval local $opt
            if [ -r "$realdevdir/$opt" ]; then
                eval $opt=$(cat $realdevdir/$opt)
            else
                return 1
            fi
        done
        opts="cipher=$cipher-$ivalgorithm,size=$keysize,hash=$keyhash"
    else
        return 1
    fi

    # Set key source
    if [ $keytype = random ]; then
        keyfile="/dev/random"
    elif [ $keytype = passphrase ]; then
        keyfile="none"
    elif [ -f $realdevdir/keyfile ]; then
        keyfile=$(cat $realdevdir/keyfile)
    else
        return 1
    fi

    # Check for special mounts
    method=$(cat $cryptdevdir/method)
    mnt=""
    if [ -f $cryptdevdir/mountpoint ]; then
        mnt=$(cat $cryptdevdir/mountpoint)
    fi
    if [ $method = swap ]; then
        $opts="$opts,swap"
    elif [ $mnt = /tmp ]; then
        $opts="$opts,tmp"
    fi

    # Check mapping name
    target=$(basename $cryptdev)

    # Check source device
    source=$realdev

    # Add entry to crypttab
    echo "$target $source $keyfile $opts" >> /target/etc/crypttab
}

for dev in $DEVICES/*; do
    [ -d "$dev" ] || continue
    cd $dev
    # skip unless encrypted
    [ -f crypt_realdev ] || continue

    partitions=
    open_dialog PARTITIONS
    while { read_line num id size type fs path name; [ "$id" ]; }; do
        [ "$fs" != free ] || continue
        partitions="$partitions $id,$path"
    done
    close_dialog

    for part in $partitions; do
        id=${part%,*}
        path=${part#*,}

        r=$(cat crypt_realdev)
        set -- $(IFS=: && echo $r)
        realdev=$1
        realdevnum=$2
        realdevdir=$3
        cryptdevdir=$dev/$id

        [ -f $realdevdir/cipher ] || continue
        [ -f $realdevdir/keytype ] || continue
        [ -f $id/method ] || continue

        # skip unless swap or to be mounted
        method=$(cat $id/method)
        if [ "$method" != swap ] && [ ! -f $id/mountpoint ]; then
            continue
        fi

        m=$(cat $realdevdir/method)
        type=${m#*/}
        realdev=$(mapdevfs $realdev)
        cryptdev=$(mapdevfs $path)

        case $type in
            loop-AES)
                loopaes_fix_fstab $realdev $realdevdir $cryptdev $cryptdevdir
                ;;
            dm-crypt|luks)
                add_crypttab_entry $realdev $realdevdir $cryptdev $cryptdevdir $type
                ;;
        esac
    done
done
