#!/bin/sh

# This script creates partman crypt disks. It does losetup or 
# cryptsetup (TODO) and then creates a partman disk.

. /lib/partman/definitions.sh

partman_devdir () {
    local d=$(echo $1 | tr / =)
    echo /var/lib/partman/devices/$d
}

partman_create_disk () {
    device=$1
    model=$2
    size=$3

    devdir=$(partman_devdir $device)
    mkdir $devdir || return 1
    cd $devdir

    echo $device > $devdir/device
    echo $model > $devdir/model
    echo $size > $devdir/size

    open_dialog OPEN $device
    read_line response
    close_dialog
    if [ "$response" = "failed" ]; then
        rm -rf $devdir
        return 1
    fi

    return 0
}

partman_create_partition () {
    local id num size type fs path name free_space free_size filesystem
    cd $(partman_devdir $1)

    open_dialog NEW_LABEL loop
    close_dialog

    # find the free space
    open_dialog PARTITIONS
    free_space=''
    while { read_line num id size type fs path name; [ "$id" ]; }; do
        if [ "$fs" = free ]; then
            free_space=$id
            free_size=$size
	    # we can't break here
        fi
    done
    close_dialog

    # create partition in the free space
    if [ "$free_space" ]; then
        open_dialog NEW_PARTITION primary ext2 $free_space full $free_size
        read_line num id size type fs path name
        close_dialog
        if [ "$id" ]; then
            open_dialog GET_FILE_SYSTEM $id 
            read_line filesystem
            close_dialog
            if [ "$filesystem" != none ]; then
                open_dialog CHANGE_FILE_SYSTEM $id $filesystem
                close_dialog
            fi
        fi
    fi
    open_dialog DISK_UNCHANGED
    close_dialog
    echo $id
}

create_crypt_disk () {
    local dev id num size path cryptdev type cipher
    dev=$1
    id=$2
    num=$3
    size=$4
    path=$5

    type=$(cat $id/crypt_type)
    cipher=$(cat $id/cipher)
    keytype=$(cat $id/keytype)
    cryptdev=$(cat $id/crypt_active)

    templ="partman-crypto/text/cryptdev_description"
    db_subst $templ CIPHER $cipher
    db_subst $templ KEYTYPE $keytype
    db_metaget $templ description || RET=''
    model="$RET"
    if [ -z "$model" ]; then
       model="${cipher} ${keytype}"
    fi

    cryptdir=$(partman_devdir $cryptdev)
    if [ ! -d $cryptdir ]; then
        partman_create_disk $cryptdev "$model" $size
        if [ $? -ne 0 ]; then
            return 2
        fi
    fi

    cryptid=$(partman_create_partition $cryptdev)
    if [ -z $cryptid ]; then
        return 3
    fi

    echo $path:$num:$dev/$id > $cryptdir/crypt_realdev
    return 0
}

for dev in /var/lib/partman/devices/*; do
    [ -d "$dev" ] || continue
    cd $dev
    partitions=
    open_dialog PARTITIONS
    while { read_line num id size type fs path name; [ "$id" ]; }; do
        if [ "$fs" != free ]; then
            partitions="$partitions $id:$num:$size:$path"
        fi
    done
    close_dialog

    for p in $partitions; do
        set -- $(IFS=: && echo $p)
        id=$1
        num=$2
        size=$3
        path=$4

        cd $dev

        [ -f $id/method ] || continue
        [ -f $id/cipher ] || continue
        [ -f $id/crypt_type ] || continue
        [ -f $id/crypt_active ] || continue

        method=$(cat $id/method)
        [ "$method" = crypto ] || continue
        
        if ! create_crypt_disk $dev $id $num $size $path; then
            db_fset partman-crypto/init_failed seen false
            db_input critical partman-crypto/init_failed
            db_go || true
            continue
        fi
    done
done

# vim:set ts=4 sw=4 expandtab:
